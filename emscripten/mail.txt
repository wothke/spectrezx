Hi again..

I spent some time to improve my web player version and as you suggested have switched my impl to the kind of code used in foobar2000. This seems to have worked as far as all the stuff that played before still works with the "new" impl.

Unfortunately this change alone did not automatically make all the archived songs work and I investigated a bit based on an archived *.ay song (see attachment).

The first thing I found was that the impl in ay.cpp did not correctly parse the file due to unaligned int16_t issues. It seems that while it is possible to access an unaligned 16-bit value while in the struct it is not possible to directly use a pointer to the unaligned memory location, i.e.:

// this works
short x= struct.SomeUnalignedInt; 


// this does not work 
void test(short *ptr) {
short y= *ptr; // comiler no longer "knows" unaligned access is needed
}
test(&struct.SomeUnalignedInt);


I fixed this problem in ay.cpp (by adding packed struct the built-in 16-bit types and use those in the method signatures), e.g.

const uint8_t* GetPointerNocheck(const RawInt16& beField) const
{
// NOTICE regarding unaligned 'short' issue: as long as unaligned data is directly 
// accessed via the wrapping RawInt16 struct the correct value can still be recovered.. 
// but IT DOES NOT work to use a direct pointer to the 'short' and to pass on that pointer, 
// e.g. as an argument to some function call (the information needed to correctly address the 
// data is no longer available for the pointer)
unsigned short s= beField.Val;
const int16_t relOffset = fromBE<uint16_t>(s);
return safe_ptr_cast<const uint8_t*>(&beField) + relOffset;
}



There is one thing that puzzles me in ay.cpp: Is there a reason why signed int16_t are used for some of the struct fields (e.g. various offsets in Header and ModuleDescription)? Does any of the logic actually expect signed values here?

In any case it looks as if the parsing now runs through.. but the code still fails when it tries to initialize the player with one of the subsongs (I am basically doing this by calling first get_song_info and then decode_initialize using the respective song id - see attached source) 



> --
> With best wishes
> Vitamin/CAIG/2001
>